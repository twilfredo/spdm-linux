What:		/sys/devices/.../authenticated
Date:		June 2024
Contact:	Lukas Wunner <lukas@wunner.de>
Description:
		This file contains 1 if the device authenticated successfully
		with SPDM (Security Protocol and Data Model).  It contains 0 if
		the device failed authentication (and may thus be malicious).

		Writing "re" to this file causes reauthentication.
		That may be opportune after updating the device keyring.
		The device keyring of the PCI bus is named ".cma"
		(Component Measurement and Authentication).

		Reauthentication may also be necessary after device identity
		has mutated, e.g. after downloading firmware to an FPGA device.

		The file is not visible if authentication is unsupported
		by the device.

		If the kernel could not determine whether authentication is
		supported because memory was low or communication with the
		device was not working, the file is visible but accessing it
		fails with error code ENOTTY.

		This prevents downgrade attacks where an attacker consumes
		memory or disturbs communication in order to create the
		appearance that a device does not support authentication.

		The reason why authentication support could not be determined
		is apparent from "dmesg".  To re-probe authentication support
		of PCI devices, exercise the "remove" and "rescan" attributes.


What:		/sys/devices/.../certificates/
What:		/sys/devices/.../certificates/slot[0-7]
Date:		June 2024
Contact:	Lukas Wunner <lukas@wunner.de>
Description:
		The "certificates" directory provides access to the certificate
		chains contained in the up to 8 slots of a device.

		A certificate chain is the concatenation of one or more ASN.1
		DER-encoded X.509 v3 certificates (SPDM 1.0.0 sec 4.9.2.1).
		It can be examined as follows::

		 # openssl storeutl -text certificates/slot0

		A common use case is to add the first certificate in a chain
		to the keyring of trusted root certificates (".cma" in this
		example) after comparing its fingerprint to the one provided
		by the device manufacturer::

		 # openssl x509 -in certificates/slot0 -fingerprint -nocert
		 # keyctl padd asymmetric "" %:.cma < certificates/slot0
		 # echo re > authenticated

		The file size of each slot is always 65535 bytes (the maximum
		size of a certificate chain per SPDM 1.0.0 table 18), even if
		the certificate chain in the slot is actually smaller.

		Unprovisioned slots are represented as empty files.

		Unsupported slots (introduced by SPDM 1.3 margin no 366) are
		not visible.  If the device only supports SPDM version 1.2 or
		earlier, all 8 slots are assumed to be supported and therefore
		visible.

		The kernel learns which slots are supported when authenticating
		the device for the first time.  Hence, no slots are visible
		until at least one authentication attempt has been performed.

		SPDM doesn't support on-demand retrieval of certificate chains,
		so the kernel caches them when (re-)authenticating the device.
		SPDM allows provisioning slots behind the kernel's back by
		sending a SET_CERTIFICATE request through a different transport
		(e.g. via MCTP from a Baseboard Management Controller).
		SPDM does not specify how to notify the kernel of such events,
		so unless reauthentication is manually initiated to update the
		kernel's cache, the "slot[0-7]" files may contain stale data.


What:		/sys/devices/.../signatures/
What:		/sys/devices/.../signatures/[0-9]*_signature
What:		/sys/devices/.../signatures/[0-9]*_transcript
What:		/sys/devices/.../signatures/[0-9]*_hash_algorithm
What:		/sys/devices/.../signatures/[0-9]*_combined_spdm_prefix
What:		/sys/devices/.../signatures/[0-9]*_certificate_chain
Date:		June 2024
Contact:	Lukas Wunner <lukas@wunner.de>
Description:
		The "signatures" directory contains a log of signatures
		received from the device to allow for their re-verification.
		It is meant for remote attestation services which do not trust
		the kernel to have verified the signatures correctly or which
		want to apply policy constraints of their own.

		Each signature is exposed as a separate file.  The filename
		is prefixed with a monotonically increasing, unsigned, 32 bit
		number, starting at 0.

		The signature is computed over the "transcript" file, which is
		a concatenation of all SPDM messages exchanged with the device.
		SPDM 1.2 and newer hash the transcript with "hash_algorithm"
		and prepend the "combined_spdm_prefix" before computing the
		signature (SPDM 1.2.0 sec 15).  For SPDM 1.0 and 1.1, that step
		is omitted and "combined_spdm_prefix" is an empty file.

		The signature is verified against the leaf certificate in the
		"certificate_chain".  To save memory, "certificate_chain" is
		a symbolic link to the slot used for signature generation.
		If the slot has since been provisioned with a different
		certificate chain, verification of the signature will fail.

		In bash syntax, the signature is verified as follows::

		 # number of signature to verify
		 num=0

		 # split certificate chain into individual certificates
		 openssl storeutl -text ${num}_certificate_chain | \
		     csplit -z -f /tmp/cert - '/^[0-9]*: Certificate$/' '{*}'

		 # extract public key from leaf certificate
		 leaf_cert=$(\ls /tmp/cert?? | tail -1)
		 openssl x509 -pubkey -in ${leaf_cert} -out ${leaf_cert}.pub

		 # verify signature
		 if [ \! -s ${num}_combined_spdm_prefix ] ; then
		     # SPDM 1.0 and 1.1
		     openssl dgst -$(cat ${num}_hash_algorithm) \
		         -signature ${num}_signature -verify ${leaf_cert}.pub \
		         ${num}_transcript
		 else
		     # SPDM 1.2 and newer
		     openssl dgst -$(cat ${num}_hash_algorithm) \
		         -binary -out /tmp/transcript_hashed ${num}_transcript
		     openssl dgst -$(cat ${num}_hash_algorithm) \
		         -signature ${num}_signature -verify ${leaf_cert}.pub \
		         ${num}_combined_spdm_prefix /tmp/transcript_hashed
		 fi

		Note: The above works for RSA signatures, but not for ECDSA.
		SPDM encodes ECDSA signatures in P1363 format (concatenation of
		two raw integers), whereas openssl only supports X9.62 format
		(ASN.1 DER sequence of two integers).  There is no command line
		utility to convert between the two formats, but most popular
		crypto libraries offer conversion routines:

		| https://github.com/java-crypto/cross_platform_crypto/blob/main/docs/ecdsa_signature_conversion.md

		The "transcript" file can be fed to a protocol dissector to
		examine the SPDM messages it contains:

		| https://github.com/th-duvanel/spdm-wid
		| https://github.com/jyao1/wireshark-spdm
		| https://github.com/DMTF/spdm-dump

		Note:  To ease signature verification, the "transcript" file
		does not contain the trailing signature.  However the signature
		is part of the final CHALLENGE_AUTH or MEASUREMENT message,
		so the protocol dissector needs to be fed the concatenation of
		"transcript" and "signature".

		Signatures are added to the log even if the kernel was unable
		to verify them (e.g. due to a missing trusted root certificate
		or forged signature).  Thereby, remote attestation services
		may make up their own mind on the signature's validity.

		Because the number prefixed to the filenames is 32 bit, it
		wraps around to 0 after 4,294,967,295 signatures.  The kernel
		avoids filename collisions on wraparound by purging old files,
		subject to the limit set by "sysctl spdm.max_signatures_size"
		(which defaults to 16 MiB).  It is advisable to regularly save
		backups on non-volatile storage to retain access to signatures
		that have been purged (or across reboots)::

		 # tar -u -h -f /path/to/signatures.tar signatures/

		The ctime of each file is the reception time of the signature.
		However if the signature was received before the device became
		registered in sysfs, the ctime is the registration time of the
		device.


What:		/sys/devices/.../signatures/[0-9]*_type
Date:		June 2024
Contact:	Lukas Wunner <lukas@wunner.de>
Description:
		This file contains the type of event that led to signature
		generation.  It is one of (sans quotes):

		"responder-challenge_auth signing"
		"responder-measurements signing"


What:		/sys/devices/.../signatures/[0-9]*_requester_nonce
What:		/sys/devices/.../signatures/[0-9]*_responder_nonce
Date:		June 2024
Contact:	Lukas Wunner <lukas@wunner.de>
Description:
		These files contain the 32 byte nonce chosen by requester and
		responder.  They allow remote attestation services to verify
		freshness (uniqueness) of the nonces.  Nonces used more than
		once can be identified with::

		 # hexdump -e '32/1 "%02x" "\n"' [0-9]*_nonce | sort | \
		   uniq -c | grep -v '^      1'

		Remote attestation services may also want to verify that the
		entropy of the nonces is acceptable::

		 # ent 0_requester_nonce

		Note:  The nonces are also contained in the "transcript", but
		their offsets within the transcript are variable.  It would be
		necessary to parse the SPDM messages in the transcript to find
		and extract the nonces, which is cumbersome.  That's why they
		are exposed as separate files.


What:		/sys/devices/.../signatures/next_requester_nonce
Date:		June 2024
Contact:	Lukas Wunner <lukas@wunner.de>
Description:
		If you do not trust the kernel to always use a fresh nonce,
		write 32 bytes to this file to set the requester nonce used
		in the next SPDM authentication or measurement sequence.

		Meant for remote attestation services.  You are responsible
		for providing a nonce with sufficient entropy.  The kernel
		only uses the nonce once, so provide a new one every time
		you reauthenticate or measure the device.  If you do not
		provide a nonce, the kernel generates a random one.

		After the nonce has been consumed, it becomes readable as
		the newest [0-9]*_requester_nonce, which proves its usage::

		 # dd if=/dev/random bs=32 count=1 | \
		   tee signatures/next_requester_nonce | hexdump
		 0000000 e0 77 91 54 bd 56 99 c2 ea 4f 0b 1a 7f ba 6e 59
		 0000010 8f ee f6 b2 26 82 58 34 9e e5 8c 8a 31 58 29 7e

		 # echo re > authenticated

		 # hexdump $(\ls -t signatures/[0-9]*_requester_nonce | head -1)
		 0000000 e0 77 91 54 bd 56 99 c2 ea 4f 0b 1a 7f ba 6e 59
		 0000010 8f ee f6 b2 26 82 58 34 9e e5 8c 8a 31 58 29 7e
